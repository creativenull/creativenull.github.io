(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{307:function(e,t,n){"use strict";n.r(t);var a=n(42),o=Object(a.a)({},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("PostHeader"),e._v(" "),n("div",{staticClass:"tip custom-block"},[n("p",{staticClass:"custom-block-title"},[e._v("Info")]),e._v(" "),n("p",[e._v("If you haven't read the first part, "),n("a",{attrs:{href:"https://thecreativenobody.github.io/posts/2019/02/08/embedded-dev-env-in-vim-2019-p1.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("click here"),n("OutboundLink")],1),e._v(" to read that first before you read part two.")])]),e._v(" "),n("p",[e._v("Last time, I showed you the plugins I used and setup their settings in a .vimrc (for vim) or init.vim (for nvim) file. This second part will guide you through setting up "),n("code",[e._v("cmake")]),e._v(" and making sure our Langauge Server/Client is able to work properly with our custom compiler.")]),e._v(" "),n("h2",{attrs:{id:"build-custom-toolchain"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#build-custom-toolchain","aria-hidden":"true"}},[e._v("#")]),e._v(" Build custom toolchain")]),e._v(" "),n("p",[e._v("Since we're building our program to be run in a microcontroller, we need a dedicated toolchain to compile our program. The microcontroller I am using is the TI TM4C129EXL ARM microcontroller. And since GCC has ARM support we can use GCC to compile out program. To upload the program we will use the UniFlash tool provided by TI. Unfortunately, we won't be able to debug for this specific microcontroller (I haven't found a working solution yet) but but debugging any other\nmicrocontroller OpenOCD is a great tool to enable that, however I won't be covering that in this guide - maybe part 3?")]),e._v(" "),n("p",[e._v("First, we'll have to create a toolchain file that we can tell "),n("code",[e._v("cmake")]),e._v(" to use instead of our default installed toolchain. But before we can do that, we'll need to download the ARM GCC toolchain from developer.arm.com. Then create our environment, I'll keep the compilers and projects seperate, since I am using a Linux distro (Manjaro) I will assume you are using the same or are familiar on how to call programs in the terminal/console. Here is how our workspace will look like, you can make this workspace anywhere in your PC - I have it in a folder inside my Home directory (~/embedded):")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(".\n├── compilers\n└── projects\n\n")])])]),n("p",[e._v("Download and extract the compiler from ARM - lucky for us we don't need to compile since binary sources are available. If you prefer a clicky "),n("a",{attrs:{href:"https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads",target:"_blank",rel:"noopener noreferrer"}},[e._v("link"),n("OutboundLink")],1),e._v(":")]),e._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Enter into compilers directory")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("cd")]),e._v(" compilers\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("wget")]),e._v(" https://developer.arm.com/-/media/Files/downloads/gnu-rm/7-2017q4/gcc-arm-none-eabi-7-2017-q4-major-linux.tar.bz2\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Extract the file")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("tar")]),e._v(" xjfv gcc-arm-none-eabi-7-2017-q4-major-linux.tar.bz2\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Remove tar bz2 file")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("rm")]),e._v(" gcc-arm-none-eabi-7-2017-q4-major-linux.tar.bz2\n\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("cd")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v("\n")])])]),n("p",[e._v("Create new project, I used an example file from TI to get the startup and link script to work for TM4C. So we will also need to download TivaWare - which came with Code Composer Studio. I copied mine from where I installed it into the current project:")]),e._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Create new project")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("cd")]),e._v(" projects\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("mkdir")]),e._v(" blinky\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("cd")]),e._v(" blinky\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Copy linker and startup script from example file")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("cp")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$HOME")]),e._v("/ti/tivaware_c_series_2_1_4_178/examples/boards/ek-tm4c129exl/blinky/blinky.ld TM4C129ENCPDT.ld\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("cp")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$HOME")]),e._v("/ti/tivaware_c_series_2_1_4_178/examples/boards/ek-tm4c129exl/blinky/startup_gcc.c "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(".")]),e._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Copy the blink program to test it out")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("mkdir")]),e._v(" src\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("cp")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$HOME")]),e._v("/ti/tivaware_c_series_2_1_4_178/examples/boards/ek-tm4c129exl/blinky/blinky.c src/main.c\n")])])]),n("p",[e._v("Create src folder where all our source files will go inside. We'll also need to create the CMakeLists.txt file along with a toolchain file since we want to use a custom "),n("code",[e._v("gcc")]),e._v(" instead of the machine installed one.")]),e._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# CMakeLists and toolchain files")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("touch")]),e._v(" CMakeLists.txt toolchain.cmake\n")])])]),n("p",[e._v("Let's start with the toolchain.cmake file.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("# ---\n# toolchain.cmake\n# ---\n\nset(CMAKE_SYSTEM_NAME Generic)\nset(CMAKE_SYSTEM_PROCESSOR ARM)\n\nset(ARM_GCC_PATH $ENV{EMBEDDED_ROOT}/compilers/gcc-arm-none-eabi-7-2017-q4-major/bin)\n\nset(CMAKE_C_COMPILER ${ARM_GCC_PATH}/arm-none-eabi-gcc)\nset(CMAKE_CXX_COMPILER ${ARM_GCC_PATH}/arm-none-eabi-g++)\nset(CMAKE_ASM_COMPILER ${ARM_GCC_PATH}/arm-none-eabi-gcc)\n\n# tells CMake not to try to link executables during its internal checks\n# things are not going to link properly without a linker script\nset(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)\n\nset(CMAKE_OBJCOPY ${ARM_GCC_PATH}/arm-none-eabi-objcopy)\nset(CMAKE_OBJDUMP ${ARM_GCC_PATH}/arm-none-eabi-objdump)\nset(CMAKE_SIZE ${ARM_GCC_PATH}/arm-none-eabi-size)\nset(CMAKE_DEBUGGER ${ARM_GCC_PATH}/arm-none-eabi-gdb)\nset(CMAKE_CPPFILT ${ARM_GCC_PATH}/arm-none-eabi-c++filt)\n")])])]),n("p",[e._v("And now we add content in CMakeLists.txt file. I copied the compiler and linker flags from Code Composer Studio and how they compile the program for TM4C microcontroller.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('# ---\n# CMakeLists.txt\n# ---\n\ncmake_minimum_required(VERSION 3.10)\n\nproject(blinky)\nset(PROJECT_TARGET ${PROJECT_NAME}.out)\nset(PROJECT_PART TM4C129ENCPDT)\n\nfile(GLOB SOURCES ${PROJECT_SOURCE_DIR}/src/*.c)\n\n# Startup and linker file provided by Tiva\nenable_language(ASM)\nset(STARTUP_FILE startup_gcc.c)\nset(LINKER_SCRIPT ${PROJECT_PART}.ld)\n\n# Bin file to create\nadd_executable(${PROJECT_TARGET} ${STARTUP_FILE} ${SOURCES})\n\n# Tivaware includes and libraries\nset(TIVAWARE_PATH $ENV{HOME}/ti/tivaware_c_series_2_1_4_178)\ntarget_include_directories(${PROJECT_TARGET} PUBLIC ${TIVAWARE_PATH})\ntarget_link_libraries(${PROJECT_TARGET} ${TIVAWARE_PATH}/driverlib/gcc/libdriver.a)\n\n# Linker flags\nset_target_properties(${PROJECT_TARGET} PROPERTIES LINK_FLAGS\n\t"-mthumb \\\n\t-march=armv7e-m \\\n\t-mcpu=cortex-m4 \\\n\t-mfloat-abi=hard \\\n\t-mfpu=fpv4-sp-d16 \\\n\t-nostartfiles \\\n\t-static \\\n\t-Wl,-T,${PROJECT_SOURCE_DIR}/${LINKER_SCRIPT} \\\n\t-Wl,--gc-sections")\n\n# Compiler flags\ntarget_compile_options(${PROJECT_TARGET} PUBLIC\n\t-g\n\t-mthumb\n\t-mcpu=cortex-m4\n\t-mfpu=fpv4-sp-d16\n\t-mfloat-abi=hard\n\t-mabi=aapcs\n\t-Os\n\t-ffunction-sections\n\t-fdata-sections\n\t-MD\n\t-std=c99\n\t-Wall\n\t-pedantic\n\t-DPART_${PROJECT_PART}\n\t-DTARGET_IS_TM4C129_RA1\n\t-Dgcc\n\t-c)\n\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n')])])]),n("p",[e._v("Now I must mention that this was a quick simple way of getting embedded development setup for vim, there are some parts I will explain that will need a bit of manual modification for this to work for your environment. For our simple blink program, all we needed was the "),n("code",[e._v("libdriver")]),e._v(" library that came with TivaWare. I simple linked it from where I had my TivaWare installed on my machine which is show above as "),n("code",[e._v("TIVAWARE_PATH")]),e._v(".")]),e._v(" "),n("p",[e._v("Finally, everything is assembled and ready for us to compile our program. Let's create a new folder where all the build files will go into, and change our directory into it.")]),e._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[n("span",{pre:!0,attrs:{class:"token function"}},[e._v("mkdir")]),e._v(" build\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("cd")]),e._v(" build\n")])])]),n("p",[e._v("Now we want to tell "),n("code",[e._v("cmake")]),e._v(" to build the files, but we want it to use the toolchain file we created instead of "),n("code",[e._v("cmake")]),e._v(" looking in the machine installed "),n("code",[e._v("gcc")]),e._v(". And once that is successful we can compile our project by calling "),n("code",[e._v("make")]),e._v(" after that.")]),e._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# inside the build/ directory")]),e._v("\ncmake -DCMAKE_TOOLCHAIN_FILE"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v("/toolchain.cmake "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v("\n-- The C compiler identification is GNU 7.2.1\n-- The CXX compiler identification is GNU 7.2.1\n-- Check "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),e._v(" working C compiler: ~/embedded/compilers/gcc-arm-none-eabi-7-2017-q4-major/bin/arm-none-eabi-gcc\n-- Check "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),e._v(" working C compiler: ~/embedded/compilers/gcc-arm-none-eabi-7-2017-q4-major/bin/arm-none-eabi-gcc -- works\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info - "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("done")]),e._v("\n-- Detecting C compile features\n-- Detecting C compile features - "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("done")]),e._v("\n-- Check "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),e._v(" working CXX compiler: ~/embedded/compilers/gcc-arm-none-eabi-7-2017-q4-major/bin/arm-none-eabi-g++\n-- Check "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),e._v(" working CXX compiler: ~/embedded/compilers/gcc-arm-none-eabi-7-2017-q4-major/bin/arm-none-eabi-g++ -- works\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("done")]),e._v("\n-- Detecting CXX compile features\n-- Detecting CXX compile features - "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("done")]),e._v("\n-- The ASM compiler identification is GNU\n-- Found assembler: ~/embedded/compilers/gcc-arm-none-eabi-7-2017-q4-major/bin/arm-none-eabi-gcc\n-- Configuring "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("done")]),e._v("\n-- Generating "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("done")]),e._v("\n-- Build files have been written to: ~/embedded/guide-tutorial/projects/blinky/build\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# finally, call make to compile the program")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("make")]),e._v("\nScanning dependencies of target blinky.out\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" 33%"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" Building C object CMakeFiles/blinky.out.dir/startup_gcc.c.obj\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" 66%"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" Building C object CMakeFiles/blinky.out.dir/src/main.c.obj\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("100%"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" Linking C executable blinky.out\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("100%"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" Built target blinky.out\n")])])]),n("p",[e._v("If everything went well, then we will have a "),n("code",[e._v("blinky.out")]),e._v(" in our "),n("code",[e._v("build/")]),e._v(" directory! Congratulate yourself for getting this far!")]),e._v(" "),n("p",[e._v("Now all that remains is that we are able to open up vim and try to get auto-completion and syntax/error checking working. If you remember from the first part, we had LangaugeClient-neovim as our LSP client to run "),n("code",[e._v("clangd")]),e._v(" which is a Langauge Server that will run in the background providing diagnostics and auto-completion just like an IDE. But in order for "),n("code",[e._v("clangd")]),e._v(" to provide us IDE-like features we need to provide it with a\n"),n("code",[e._v("compile_commands.json")]),e._v(" file that cmake built for us in the "),n("code",[e._v("build/")]),e._v(" directory.")]),e._v(" "),n("p",[e._v("Since we need this file in the root of our project, we could copy the file our to the root and have that solved. The downside to that is when we add new files and recompile our program we end up with the old "),n("code",[e._v("compile_commands.json")]),e._v(" file in the root, which we will need to update again manually. The best approach to this is to symbolically link "),n("code",[e._v("compile_commands.json")]),e._v(" to the root, so when it updates then we don't need to worry about manually copying the file to the root.")]),e._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# in the root of project - blinky/")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("ln")]),e._v(" -s build/compile_commands.json "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(".")]),e._v("\n")])])]),n("p",[e._v("Open "),n("code",[e._v("src/main.c")]),e._v(" in vim and start using the type any of the function that are available. As you type you should be able to get a list of options auto-completion will prompt for completion. You can go to the definition of a function declared by hovering over the function and pressing "),n("code",[e._v("<F5>")]),e._v(" to show the LSP options and typing 'definition'. You can make a key binding for each LSP option. Here is my updated "),n("code",[e._v("init.vim")]),e._v(" with individual key bindings.")]),e._v(" "),n("div",{staticClass:"language-vim extra-class"},[n("pre",{pre:!0,attrs:{class:"language-vim"}},[n("code",[e._v("nnoremap "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("F5"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("call")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("LanguageClient_contextMenu")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("CR"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\nnnoremap "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("leader"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),n("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("gd")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("call")]),e._v(" LanguageClient#"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("textDocument_definition")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("CR"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\nnnoremap "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("leader"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("gf "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("call")]),e._v(" LanguageClient#"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("textDocument_formatting")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("CR"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\nnnoremap "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("leader"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("gr")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("call")]),e._v(" LanguageClient#"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("textDocument_rename")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("CR"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n")])])]),n("p",[e._v("This concludes the 2nd part of the series - Embedded development environment in Vim - I would like to revist this in the future and keep it up-to-date as much as possible. I hope you enjoyed this guide.")]),e._v(" "),n("PostFooter")],1)},[],!1,null,null,null);t.default=o.exports}}]);